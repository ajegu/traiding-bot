# Task 1.1 - Backend Terraform (S3 + DynamoDB Lock)

## Statut : En cours

## Objectif

Configurer le backend Terraform distant avec :
- Un bucket S3 pour stocker l'état Terraform
- Une table DynamoDB pour le verrouillage de l'état (éviter les modifications concurrentes)

## Contexte

Le backend distant est essentiel pour :
- Partager l'état entre les membres de l'équipe
- Sécuriser l'état (chiffrement S3)
- Éviter les conflits avec le verrouillage DynamoDB
- Permettre le déploiement via CI/CD

## Contraintes

- **Free Tier obligatoire** : S3 et DynamoDB doivent rester dans les limites gratuites
- Région : `eu-west-1` (Ireland)
- Chiffrement activé sur le bucket S3

## Actions à Réaliser

### 1. Créer la structure de dossiers Terraform

```
terraform/
├── bootstrap/           # Ressources pour le backend (à créer en premier)
│   ├── main.tf
│   ├── variables.tf
│   ├── outputs.tf
│   └── providers.tf
├── environments/
│   ├── dev/
│   └── prod/
├── modules/
└── ...
```

### 2. Créer le module bootstrap

#### 2.1 Fichier `terraform/bootstrap/providers.tf`

```hcl
terraform {
  required_version = ">= 1.6.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region

  default_tags {
    tags = {
      Project   = "trading-bot"
      ManagedBy = "terraform"
      Component = "bootstrap"
    }
  }
}
```

#### 2.2 Fichier `terraform/bootstrap/variables.tf`

```hcl
variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "eu-west-1"
}

variable "project_name" {
  description = "Nom du projet"
  type        = string
  default     = "trading-bot"
}
```

#### 2.3 Fichier `terraform/bootstrap/main.tf`

```hcl
locals {
  bucket_name = "${var.project_name}-terraform-state"
  table_name  = "${var.project_name}-terraform-lock"
}

# Bucket S3 pour l'état Terraform
resource "aws_s3_bucket" "terraform_state" {
  bucket = local.bucket_name

  lifecycle {
    prevent_destroy = true
  }

  tags = {
    Name = local.bucket_name
  }
}

# Activer le versioning sur le bucket
resource "aws_s3_bucket_versioning" "terraform_state" {
  bucket = aws_s3_bucket.terraform_state.id

  versioning_configuration {
    status = "Enabled"
  }
}

# Chiffrement du bucket
resource "aws_s3_bucket_server_side_encryption_configuration" "terraform_state" {
  bucket = aws_s3_bucket.terraform_state.id

  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}

# Bloquer l'accès public au bucket
resource "aws_s3_bucket_public_access_block" "terraform_state" {
  bucket = aws_s3_bucket.terraform_state.id

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}

# Table DynamoDB pour le verrouillage
resource "aws_dynamodb_table" "terraform_lock" {
  name         = local.table_name
  billing_mode = "PAY_PER_REQUEST"  # Free Tier compatible
  hash_key     = "LockID"

  attribute {
    name = "LockID"
    type = "S"
  }

  tags = {
    Name = local.table_name
  }
}
```

#### 2.4 Fichier `terraform/bootstrap/outputs.tf`

```hcl
output "s3_bucket_name" {
  description = "Nom du bucket S3 pour l'état Terraform"
  value       = aws_s3_bucket.terraform_state.id
}

output "s3_bucket_arn" {
  description = "ARN du bucket S3"
  value       = aws_s3_bucket.terraform_state.arn
}

output "dynamodb_table_name" {
  description = "Nom de la table DynamoDB pour le verrouillage"
  value       = aws_dynamodb_table.terraform_lock.name
}

output "dynamodb_table_arn" {
  description = "ARN de la table DynamoDB"
  value       = aws_dynamodb_table.terraform_lock.arn
}

output "backend_config" {
  description = "Configuration à utiliser pour le backend"
  value       = <<-EOT
    terraform {
      backend "s3" {
        bucket         = "${aws_s3_bucket.terraform_state.id}"
        key            = "state/terraform.tfstate"
        region         = "${var.aws_region}"
        encrypt        = true
        dynamodb_table = "${aws_dynamodb_table.terraform_lock.name}"
      }
    }
  EOT
}
```

### 3. Déployer le bootstrap

```bash
cd terraform/bootstrap

# Initialiser Terraform
terraform init

# Vérifier le plan
terraform plan

# Appliquer les changements
terraform apply
```

### 4. Créer le fichier backend.tf principal

Après le déploiement du bootstrap, créer `terraform/backend.tf` :

```hcl
terraform {
  backend "s3" {
    bucket         = "trading-bot-terraform-state"
    key            = "state/terraform.tfstate"
    region         = "eu-west-1"
    encrypt        = true
    dynamodb_table = "trading-bot-terraform-lock"
  }
}
```

### 5. Créer les fichiers de base Terraform

#### 5.1 Fichier `terraform/versions.tf`

```hcl
terraform {
  required_version = ">= 1.6.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}
```

#### 5.2 Fichier `terraform/providers.tf`

```hcl
provider "aws" {
  region = var.aws_region

  default_tags {
    tags = local.common_tags
  }
}
```

#### 5.3 Fichier `terraform/variables.tf`

```hcl
variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "eu-west-1"
}

variable "environment" {
  description = "Environnement de déploiement"
  type        = string
  default     = "dev"

  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be dev, staging, or prod."
  }
}

variable "project_name" {
  description = "Nom du projet"
  type        = string
  default     = "trading-bot"
}
```

#### 5.4 Fichier `terraform/locals.tf`

```hcl
locals {
  name_prefix = "${var.project_name}-${var.environment}"

  common_tags = {
    Project     = var.project_name
    Environment = var.environment
    ManagedBy   = "terraform"
  }
}
```

#### 5.5 Fichier `terraform/outputs.tf`

```hcl
output "environment" {
  description = "Environnement actuel"
  value       = var.environment
}

output "name_prefix" {
  description = "Préfixe de nommage des ressources"
  value       = local.name_prefix
}
```

### 6. Vérifier le déploiement

```bash
# Depuis le dossier terraform/
terraform init
terraform validate
terraform plan
```

## Checklist

- [ ] Créer le dossier `terraform/bootstrap/`
- [ ] Créer `terraform/bootstrap/providers.tf`
- [ ] Créer `terraform/bootstrap/variables.tf`
- [ ] Créer `terraform/bootstrap/main.tf`
- [ ] Créer `terraform/bootstrap/outputs.tf`
- [ ] Exécuter `terraform init` dans bootstrap
- [ ] Exécuter `terraform apply` dans bootstrap
- [ ] Vérifier la création du bucket S3 dans la console AWS
- [ ] Vérifier la création de la table DynamoDB dans la console AWS
- [ ] Créer `terraform/backend.tf`
- [ ] Créer `terraform/versions.tf`
- [ ] Créer `terraform/providers.tf`
- [ ] Créer `terraform/variables.tf`
- [ ] Créer `terraform/locals.tf`
- [ ] Créer `terraform/outputs.tf`
- [ ] Exécuter `terraform init` dans le dossier principal
- [ ] Valider avec `terraform validate`

## Ressources AWS Créées

| Ressource | Nom | Description |
|-----------|-----|-------------|
| S3 Bucket | `trading-bot-terraform-state` | Stockage de l'état Terraform |
| DynamoDB Table | `trading-bot-terraform-lock` | Verrouillage de l'état |

## Notes Importantes

1. **Le bootstrap utilise un état local** : C'est normal, le bootstrap crée les ressources nécessaires pour le backend distant
2. **prevent_destroy** : Le bucket S3 est protégé contre la suppression accidentelle
3. **Versioning S3** : Permet de récupérer des versions antérieures de l'état
4. **PAY_PER_REQUEST** : Mode de facturation DynamoDB compatible Free Tier

## Prochaine Étape

Une fois cette tâche terminée, passer à l'étape **1.2 - Tables DynamoDB**.
